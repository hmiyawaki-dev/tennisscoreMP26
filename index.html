<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NODAãƒ†ãƒ‹ã‚¹ã‚¹ã‚³ã‚¢MP</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* ã‚¢ãƒ—ãƒªå…¨ä½“ã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆã‚¹ãƒãƒ›ã§ã®ã‚¿ãƒƒãƒ—ãƒã‚¤ãƒ©ã‚¤ãƒˆãªã©ã‚’ç„¡åŠ¹åŒ–ï¼‰ */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f0fdf4; }
        * { -webkit-tap-highlight-color: transparent; touch-action: manipulation; user-select: none; -webkit-user-select: none; }
        input, select { user-select: auto; -webkit-user-select: auto; }
        button { cursor: pointer; }
    </style>
    <link rel="manifest" href="./manifest.json">

    <link rel="apple-touch-icon" href="/icons/icon-180.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, createElement } = React;

        // ==========================================
        // ã‚¢ã‚¤ã‚³ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ©ãƒƒãƒ‘ãƒ¼
        // ==========================================
        const LucideIcon = ({ name, size = 24, className, ...props }) => {
            const iconData = window.lucide && window.lucide.icons ? window.lucide.icons[name] : null;
            if (!iconData) return <span style={{ width: size, height: size, display: 'inline-block' }}></span>;
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                    {iconData.map(([tag, attrs], index) => createElement(tag, { ...attrs, key: index }))}
                </svg>
            );
        };

        // ã‚¢ãƒ—ãƒªå†…ã§ä½¿ã†å„ç¨®ã‚¢ã‚¤ã‚³ãƒ³
        const Trophy = (props) => <LucideIcon name="Trophy" {...props} />;
        const Activity = (props) => <LucideIcon name="Activity" {...props} />;
        const Save = (props) => <LucideIcon name="Save" {...props} />;
        const Zap = (props) => <LucideIcon name="Zap" {...props} />;
        const Pencil = (props) => <LucideIcon name="Pencil" {...props} />;
        const Trash2 = (props) => <LucideIcon name="Trash2" {...props} />;
        const X = (props) => <LucideIcon name="X" {...props} />;
        const Menu = (props) => <LucideIcon name="Menu" {...props} />;
        const CloudUpload = (props) => <LucideIcon name="CloudUpload" {...props} />;
        const Share2 = (props) => <LucideIcon name="Share2" {...props} />;
        const RefreshCw = (props) => <LucideIcon name="RefreshCw" {...props} />;
        const LogOut = (props) => <LucideIcon name="LogOut" {...props} />;
        const Keyboard = (props) => <LucideIcon name="Keyboard" {...props} />;
        const ListIcon = (props) => <LucideIcon name="List" {...props} />;
        const MessageSquare = (props) => <LucideIcon name="MessageSquare" {...props} />;

        // ==========================================
        // å®šæ•°å®šç¾©
        // ==========================================
        const POINTS = ['0', '15', '30', '40', 'Ad', 'GAME']; 
        const DEFAULT_GAS_URL = "https://script.google.com/macros/s/AKfycbzGVV5XjhmbJBialJy5f--xm0VVuDBGahgtf1ZPW5rX_V1kPafKPBL1WRnz8i42y4gS/exec"; 
        const AUTO_SAVE_KEY = 'noda_tennis_autosave_data'; // è‡ªå‹•ä¿å­˜ç”¨ã®ã‚­ãƒ¼

        const DEFAULT_PLAYER_LIST = {
            "ç¥æˆ¸é‡ç”° ç”·": ["å·å£ æš–æ–—", "æ²³é‡ æ™ƒå¤ª", "èŠå· é›„ä»‹", "ç‰ç”° ä¸€å°†", "èˆ©å²¡ æµå¤§", "å°æ— ç´”å¹³", "é«˜æ©‹ å²ç”Ÿ", "é£¯ç”° éš¼ç”Ÿ", "å°æ©‹ æ‚ äºº", "è°·æ¾¤ æ‹“çœŸ", "æ˜¥ç”° é™½å‘", "è—¤è°· æŸŠå¸", "ä¸‰æœ¨ æœ›å¤¢", "æ‘å±± è’¼"],
            "ç¥æˆ¸é‡ç”° å¥³": ["é»’æœ¨ å‡œ", "çŸ³ç”° å®Ÿè‰", "äº”å³¶ å®‡è‰", "æ—©è¦‹ èŠ½è¡£", "å±±æœ¬ çµè²´", "çŸ³å· å¤•æ¥“", "ç¬ åŸ ç‘ é‚£", "å·ä¸­ ä¸€èŠ±", "è°·å£ æ¥“"]
        };

        const DEFAULT_MATCH_INFO = {
            matchName: 'ç·´ç¿’è©¦åˆ', isDoubles: false,
            playerA1: 'Player A1', playerA2: 'Player A2',
            playerB1: 'Player B1', playerB2: 'Player B2',
            matchType: '1set', setsToWin: 1, gamesToWinSet: 6, tiebreakAt: 6, noAd: false, 
            serverFirst: 'A', gasUrl: DEFAULT_GAS_URL
        };

        // ==========================================
        // UIéƒ¨å“ (ãƒœã‚¿ãƒ³ãƒ»ã‚«ãƒ¼ãƒ‰ãªã©)
        // ==========================================
        const Button = ({ onClick, children, className = "", variant = "primary", disabled = false, size = "md" }) => {
            const baseStyle = "font-bold rounded-lg shadow-sm transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center select-none cursor-pointer";
            const variants = {
                primary: "bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800",
                secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 active:bg-gray-100",
                success: "bg-green-600 text-white hover:bg-green-700 active:bg-green-800",
                danger: "bg-red-500 text-white hover:bg-red-600 active:bg-red-700",
                warning: "bg-yellow-400 text-yellow-900 hover:bg-yellow-500 active:bg-yellow-600"
            };
            const sizes = { sm: "px-2 py-1 text-sm", md: "px-4 py-2 text-sm", lg: "px-6 py-3 text-lg" };
            return <button onClick={onClick} className={`${baseStyle} ${variants[variant]} ${sizes[size]} ${className}`} disabled={disabled}>{children}</button>;
        };

        const Card = ({ children, className = "" }) => <div className={`bg-white rounded-xl shadow-md border border-slate-200 overflow-hidden ${className}`}>{children}</div>;

        // ==========================================
        // ã‚°ãƒ©ãƒ•æç”»ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (ã‚¹ã‚¿ãƒƒãƒ„ç”»é¢ç”¨)
        // ==========================================
        const SinglePlayerGraph = ({ data, color, playerName }) => {
            if (!data || data.length === 0) return null;
            const height = 160; const width = 300; const padding = 20; const graphHeight = height - padding * 2 - 20; const graphWidth = width - padding * 2;
            const maxGames = data.length; const xStep = maxGames > 1 ? graphWidth / (maxGames - 1) : graphWidth;
            const getCoords = (index, percent) => {
                const x = padding + index * xStep; const finalX = maxGames === 1 ? width / 2 : x; const y = height - padding - 20 - (percent / 100) * graphHeight; return `${finalX},${y}`;
            };
            const points1st = data.map((d, i) => getCoords(i, d.rate1st)).join(" ");
            const pointsTotal = data.map((d, i) => getCoords(i, d.rateTotal)).join(" ");
            return (
                <div className="w-full mb-4">
                    <h5 className="text-xs font-bold text-gray-500 mb-2 pl-2 border-l-4 flex justify-between items-center" style={{ borderColor: color }}>
                        <span>{playerName}</span>
                        <div className="flex gap-2 text-[9px] font-normal opacity-70">
                            <div className="flex items-center gap-1"><span className="w-2 h-0.5" style={{ backgroundColor: color }}></span>1st</div>
                            <div className="flex items-center gap-1"><span className="w-2 h-0.5 border-t border-dashed" style={{ borderColor: color, borderWidth: "1px" }}></span>Total</div>
                        </div>
                    </h5>
                    <svg width="100%" height={height} viewBox={`0 0 ${width} ${height}`} className="bg-slate-50 rounded border border-slate-100 select-none">
                        {[0, 50, 100].map(p => (<line key={p} x1={padding} y1={height - padding - 20 - (p / 100) * graphHeight} x2={width - padding} y2={height - padding - 20 - (p / 100) * graphHeight} stroke="#e2e8f0" strokeWidth="1" />))}
                        {maxGames > 1 && (<><polyline points={pointsTotal} fill="none" stroke={color} strokeWidth="2" strokeDasharray="4 2" opacity="0.6" /><polyline points={points1st} fill="none" stroke={color} strokeWidth="2" /></>)}
                        {data.map((d, i) => {
                            const [x1, y1] = getCoords(i, d.rate1st).split(','); const [xt, yt] = getCoords(i, d.rateTotal).split(',');
                            return (<g key={i}><circle cx={xt} cy={yt} r="2" fill={color} opacity="0.6" /><circle cx={x1} cy={y1} r="3" fill={color} /><text x={x1} y={parseFloat(y1) - 8} fontSize="9" textAnchor="middle" fill={color} fontWeight="bold">{d.rate1st}%</text><text x={x1} y={height - 5} fontSize="9" textAnchor="middle" fill="#94a3b8">{d.gameIndex}</text></g>);
                        })}
                    </svg>
                </div>
            );
        };

        const StatsGraphs = ({ gameStats, matchInfo }) => {
            const players = [
                { key: 'A1', name: matchInfo.playerA1, color: '#2563eb' },
                { key: 'A2', name: matchInfo.playerA2, color: '#60a5fa' },
                { key: 'B1', name: matchInfo.playerB1, color: '#dc2626' },
                { key: 'B2', name: matchInfo.playerB2, color: '#f87171' }
            ];
            return (
                <div>
                    <h4 className="text-sm font-bold text-gray-600 mb-2 text-center">ã‚µãƒ¼ãƒ–æˆåŠŸç‡æ¨ç§» (ã‚²ãƒ¼ãƒ æ¯)</h4>
                    <div className="grid grid-cols-1 gap-2">
                        {players.map(p => {
                            if (!p.name) return null; 
                            const pData = gameStats.filter(g => g.serverPlayer === p.key).map(g => ({ gameIndex: g.gameIndex, rate1st: g.stats.rate1st, rateTotal: g.stats.rateTotal }));
                            if (pData.length === 0) return null;
                            return <SinglePlayerGraph key={p.key} data={pData} color={p.color} playerName={p.name} />;
                        })}
                    </div>
                </div>
            );
        };

        // ==========================================
        // é¸æ‰‹é¸æŠã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
        // ==========================================
        const PlayerSelectInput = ({ label, value, onChange, playerList }) => {
            const [mode, setMode] = useState('list');
            const [team, setTeam] = useState('');
            const teams = useMemo(() => Object.keys(playerList || {}), [playerList]);
            useEffect(() => { if (mode === 'list' && teams.length > 0 && !team) setTeam(teams[0]); }, [mode, teams, team]);
            const hasData = teams.length > 0;
            return (
                <div className="bg-slate-50 p-2 rounded-md border border-slate-200">
                    <div className="flex justify-between items-center mb-1">
                        <label className="text-sm font-bold text-gray-700">{label}</label>
                        <button onClick={() => setMode(mode === 'list' ? 'manual' : 'list')} className="text-[10px] flex items-center gap-1 text-blue-600 hover:text-blue-800">{mode === 'list' ? <><Keyboard size={12}/> æ‰‹å…¥åŠ›</> : <><ListIcon size={12}/> ãƒªã‚¹ãƒˆ</>}</button>
                    </div>
                    {mode === 'list' && hasData ? (
                        <div className="flex gap-2">
                            <select className="flex-1 p-1.5 border rounded text-sm bg-white min-w-0" value={team} onChange={(e) => setTeam(e.target.value)}>{teams.map(t => <option key={t} value={t}>{t}</option>)}</select>
                            <select className="flex-[1.5] p-1.5 border rounded text-sm bg-white font-bold min-w-0" value={value || ''} onChange={(e) => onChange(e.target.value)}><option value="">é¸æŠ...</option>{playerList[team]?.map(p => <option key={p} value={p}>{p}</option>)}</select>
                        </div>
                    ) : (<input type="text" className="w-full p-1.5 border rounded text-sm bg-white" value={value || ''} onChange={(e) => onChange(e.target.value)} placeholder="åå‰" />)}
                </div>
            );
        };

        // ==========================================
        // ãƒ¢ãƒ¼ãƒ€ãƒ« (ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ç”»é¢) ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç¾¤
        // ==========================================
        const ConfirmModal = ({ isOpen, onClose, onConfirm, title, message, confirmText = "å®Ÿè¡Œ", cancelText = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«", confirmColor = "danger" }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/50 p-4 animate-in fade-in" style={{ touchAction: 'none' }}>
                    <div className="bg-white rounded-xl shadow-xl w-full max-w-sm overflow-hidden p-6 space-y-4">
                        <h3 className="font-bold text-lg text-slate-800">{title}</h3><p className="text-sm text-slate-600 whitespace-pre-wrap">{message}</p>
                        <div className="flex gap-3 pt-2"><Button variant="secondary" className="flex-1" onClick={onClose}>{cancelText}</Button><Button variant={confirmColor} className="flex-1" onClick={onConfirm}>{confirmText}</Button></div>
                    </div>
                </div>
            );
        };

        const EditModal = ({ isOpen, onClose, event, onSave, onDelete, matchInfo }) => {
            const [editedType, setEditedType] = useState(event?.type || 'RALLY');
            const [editedWinner, setEditedWinner] = useState(event?.winner || 'A');
            const [editedComment, setEditedComment] = useState(event?.comment || ''); 

            useEffect(() => { 
                if (event) { 
                    setEditedType(event.type); 
                    setEditedWinner(event.winner); 
                    setEditedComment(event.comment || ''); 
                } 
            }, [event]);

            if (!isOpen || !event) return null;
            const isFault = editedType === 'FAULT';
            const labelA = matchInfo.isDoubles ? "ãƒšã‚¢ A" : matchInfo.playerA1;
            const labelB = matchInfo.isDoubles ? "ãƒšã‚¢ X" : matchInfo.playerB1;

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 animate-in fade-in" style={{ touchAction: 'none' }}>
                    <div className="bg-white rounded-xl shadow-xl w-full max-w-sm overflow-hidden">
                        <div className="bg-slate-900 text-white p-3 flex justify-between items-center"><h3 className="font-bold flex items-center gap-2"><Pencil size={16}/> å±¥æ­´ã‚’ä¿®æ­£</h3><button onClick={onClose}><X size={20}/></button></div>
                        <div className="p-4 space-y-4">
                            <div><label className="block text-xs font-bold text-gray-500 mb-1">ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—</label><select className="w-full p-2 border rounded bg-slate-50" value={editedType} onChange={(e) => setEditedType(e.target.value)}><option value="ACE">ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ¼ã‚¹ (ã‚µãƒ¼ãƒãƒ¼P)</option><option value="SERVER_P">ã‚µãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ (ã‚µãƒ¼ãƒãƒ¼P)</option><option value="RECEIVER_P">ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ (ãƒ¬ã‚·ãƒ¼ãƒãƒ¼P)</option><option value="FAULT">ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆ (å¤±æ•—)</option><option value="DOUBLE_FAULT">ãƒ€ãƒ–ãƒ«ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆ (ãƒ¬ã‚·ãƒ¼ãƒãƒ¼P)</option></select></div>
                            {!isFault && (<div><label className="block text-xs font-bold text-gray-500 mb-1">ãƒã‚¤ãƒ³ãƒˆå‹è€…</label><div className="flex gap-2"><button onClick={() => setEditedWinner('A')} className={`flex-1 py-2 rounded border ${editedWinner === 'A' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700'}`}>{labelA}</button><button onClick={() => setEditedWinner('B')} className={`flex-1 py-2 rounded border ${editedWinner === 'B' ? 'bg-red-600 text-white border-red-600' : 'bg-white text-gray-700'}`}>{labelB}</button></div></div>)}
                            
                            <div>
                                <label className="block text-xs font-bold text-gray-500 mb-1">ã‚³ãƒ¡ãƒ³ãƒˆ (ä»»æ„)</label>
                                <input 
                                    type="text" 
                                    className="w-full p-2 border rounded bg-slate-50 text-sm" 
                                    placeholder="ã“ã®ãƒã‚¤ãƒ³ãƒˆã®ãƒ¡ãƒ¢ç­‰ã‚’è¨˜å…¥..." 
                                    value={editedComment} 
                                    onChange={(e) => setEditedComment(e.target.value)} 
                                />
                            </div>

                            <div className="pt-2 flex gap-3"><Button variant="danger" className="flex-1" onClick={onDelete}><Trash2 size={16} className="mr-1"/> å‰Šé™¤</Button><Button variant="success" className="flex-[2]" onClick={() => onSave({ ...event, type: editedType, winner: editedType === 'FAULT' ? null : editedWinner, comment: editedComment })}>ä¿å­˜ã—ã¦ä¿®æ­£</Button></div>
                        </div>
                    </div>
                </div>
            );
        };

        const GasModal = ({ isOpen, onClose, matchInfo, currentScore, onSend, onResetRequest }) => {
            if (!isOpen) return null;
            const nameA = matchInfo.isDoubles ? (matchInfo.playerA1 + "ãƒ»" + matchInfo.playerA2) : matchInfo.playerA1;
            const nameB = matchInfo.isDoubles ? (matchInfo.playerB1 + "ãƒ»" + matchInfo.playerB2) : matchInfo.playerB1;
            const handleSendScore = () => {
                let status = "è©¦åˆé–‹å§‹";
                const result = currentScore.lastGameResult;
                if (result) {
                    const { serverSide, winnerSide } = result;
                    if (winnerSide === 'A') { status = serverSide === 'A' ? "ã‚­ãƒ¼ãƒ—ã—ã¾ã—ãŸ" : "ãƒ–ãƒ¬ã‚¤ã‚¯ã—ã¾ã—ãŸ"; }
                    else { status = serverSide === 'B' ? "ã‚­ãƒ¼ãƒ—ã•ã‚Œã¾ã—ãŸ" : "ãƒ–ãƒ¬ã‚¤ã‚¯ã•ã‚Œã¾ã—ãŸ"; }
                }
                const message = `${matchInfo.matchName}\n${nameA} vs ${nameB}\n${currentScore.gamesA}-${currentScore.gamesB} ${status}`;
                onSend('score_update', { text: message });
                onClose();
            };
            const handleSendResult = () => {
                onSend('match_finish', { 
                    text: `ğŸ† *${matchInfo.matchName}* (è©¦åˆçµ‚äº†)\n${nameA} vs ${nameB}\nFinal: ${currentScore.setsA}-${currentScore.setsB} (${currentScore.gamesA}-${currentScore.gamesB})`,
                    fileName: `${matchInfo.matchName}_${nameA}vs${nameB}.csv`,
                    saveToDrive: true 
                });
                onClose();
            };
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 animate-in fade-in" style={{ touchAction: 'none' }}>
                    <div className="bg-white rounded-xl shadow-xl w-full max-w-sm overflow-hidden">
                        <div className="bg-slate-900 text-white p-3 flex justify-between items-center"><h3 className="font-bold flex items-center gap-2"><CloudUpload size={16}/> Slack/Driveé€£æº</h3><button onClick={onClose}><X size={20}/></button></div>
                        <div className="p-6 space-y-4">
                            <Button className="w-full flex gap-2 items-center justify-center" size="lg" onClick={handleSendScore}><Share2 size={20}/> é€”ä¸­çµŒéã‚’é€šçŸ¥ </Button>
                            <div className="h-px bg-slate-100 my-2"></div>
                            <Button className="w-full flex gap-2 items-center justify-center" variant="success" size="lg" onClick={handleSendResult}><Save size={20}/> çµæœã‚’Driveã¸ä¿å­˜ & é€šçŸ¥</Button>
                            <div className="h-px bg-slate-100 my-2"></div>
                            <Button className="w-full flex gap-2 items-center justify-center" variant="danger" onClick={onResetRequest}><LogOut size={20}/> è©¦åˆã‚’ä¸­æ–­ã—ã¦æ–°ã—ã„è¨˜éŒ²ã¸</Button>
                        </div>
                    </div>
                </div>
            );
        };

        // ==========================================
        // ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ (App)
        // ==========================================
        const App = () => {
            // --- çŠ¶æ…‹ç®¡ç† (State) ---
            const [screen, setScreen] = useState('setup'); 
            const [matchInfo, setMatchInfo] = useState(DEFAULT_MATCH_INFO);
            const [history, setHistory] = useState([]); 

            const [showHistory, setShowHistory] = useState(false); 
            const [showGasModal, setShowGasModal] = useState(false); 
            const [showResetConfirm, setShowResetConfirm] = useState(false); 

            // --- è‡ªå‹•å¾©æ—§ï¼ˆãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ï¼‰ç”¨ã®State ---
            const [showResumeModal, setShowResumeModal] = useState(false);
            const [pendingSavedData, setPendingSavedData] = useState(null);

            const [playerList, setPlayerList] = useState({});
            const [currentServerPlayer, setCurrentServerPlayer] = useState('A1');
            const [editingEventIndex, setEditingEventIndex] = useState(null);

            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰é¸æ‰‹ãƒªã‚¹ãƒˆã¨å‰å›ã®è©¦åˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
            useEffect(() => {
                // é¸æ‰‹ãƒªã‚¹ãƒˆã®èª­ã¿è¾¼ã¿
                const pData = localStorage.getItem('tennis_player_list');
                if (pData) { try { setPlayerList(JSON.parse(pData)); } catch(e) { setPlayerList(DEFAULT_PLAYER_LIST); } } 
                else { setPlayerList(DEFAULT_PLAYER_LIST); }

                // å‰å›ã®è©¦åˆãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ï¼‰ã®èª­ã¿è¾¼ã¿
                const saved = localStorage.getItem(AUTO_SAVE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        // å±¥æ­´ãŒ1ã¤ä»¥ä¸Šã‚ã‚‹å ´åˆã®ã¿ã€Œå†é–‹ã™ã‚‹ã‹ã€ã‚’å°‹ã­ã‚‹
                        if (parsed && parsed.history && parsed.history.length > 0) {
                            setPendingSavedData(parsed);
                            setShowResumeModal(true);
                        }
                    } catch (e) {
                        localStorage.removeItem(AUTO_SAVE_KEY); // ãƒ‡ãƒ¼ã‚¿ç ´ææ™‚ã¯å‰Šé™¤
                    }
                }
            }, []);

            // --- è‡ªå‹•ä¿å­˜ï¼ˆã‚»ãƒ¼ãƒ–ï¼‰å‡¦ç† ---
            useEffect(() => {
                // åˆæœŸèµ·å‹•ã§ã€Œå†é–‹ã™ã‚‹ã‹ã©ã†ã‹ã€ã‚’å°‹ã­ã¦ã„ã‚‹æœ€ä¸­ã¯ã‚»ãƒ¼ãƒ–å‡¦ç†ã‚’è¡Œã‚ãªã„
                if (showResumeModal) return;

                // åˆæœŸç”»é¢ã§å±¥æ­´ãŒãªã„å ´åˆã¯ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¶ˆå»ï¼ˆã¾ã£ã•ã‚‰ãªçŠ¶æ…‹ï¼‰
                if (screen === 'setup' && history.length === 0) {
                    localStorage.removeItem(AUTO_SAVE_KEY);
                } else {
                    localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify({
                        screen, matchInfo, history
                    }));
                }
            }, [screen, matchInfo, history, showResumeModal]);

            // --- ãƒ‡ãƒ¼ã‚¿å¾©æ—§ãƒ»ç ´æ£„ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
            const handleResumeYes = () => {
                if (pendingSavedData) {
                    setScreen(pendingSavedData.screen || 'setup');
                    setMatchInfo(pendingSavedData.matchInfo || DEFAULT_MATCH_INFO);
                    setHistory(pendingSavedData.history || []);
                }
                setShowResumeModal(false);
                setPendingSavedData(null);
            };

            const handleResumeNo = () => {
                localStorage.removeItem(AUTO_SAVE_KEY);
                setShowResumeModal(false);
                setPendingSavedData(null);
                // çŠ¶æ…‹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã¾ã¾ãªã®ã§ã€æ–°è¦ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”»é¢ã‹ã‚‰é–‹å§‹ã•ã‚Œã‚‹
            };

            // --- ã‚¹ã‚³ã‚¢å…¥åŠ›ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–¢æ•° ---
            const handlePoint = (type, winner) => {
                if (currentScore.winner) return; 
                setHistory(prev => [...prev, { id: Date.now(), timestamp: new Date().toISOString(), type, winner, serverPlayer: currentServerPlayer }]);
            };
            const handleUpdateHistory = (updatedEvent) => {
                setHistory(prev => { const newHist = [...prev]; if (editingEventIndex !== null) newHist[editingEventIndex] = updatedEvent; return newHist; });
                setEditingEventIndex(null);
            };
            const handleDeleteHistory = () => { setHistory(prev => prev.filter((_, i) => i !== editingEventIndex)); setEditingEventIndex(null); };
            
            const confirmReset = () => setShowResetConfirm(true); 
            const executeReset = () => { 
                setHistory([]); 
                setScreen('setup'); 
                setShowGasModal(false); 
                setShowResetConfirm(false); 
                // ãƒªã‚»ãƒƒãƒˆæ™‚ã¯è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚‚ç ´æ£„
                localStorage.removeItem(AUTO_SAVE_KEY);
            };

            // ==========================================
            // ã‚¹ã‚³ã‚¢ãƒ»ã‚¹ã‚¿ãƒƒãƒ„è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ (ã‚³ã‚¢éƒ¨åˆ†)
            // ==========================================
            const { currentScore, matchStats, timeline } = useMemo(() => {
                let state = { setsA: 0, setsB: 0, gamesA: 0, gamesB: 0, pointsA: 0, pointsB: 0, isTiebreak: false, winner: null, currentServerSide: matchInfo.serverFirst, gameServerSide: matchInfo.serverFirst, lastGameResult: null };
                
                const initStat = { totalPoints: 0, serves: 0, serves1st: 0, firstIn: 0, faults: 0, doubleFaults: 0, aces: 0 };
                let stats = { A1: { ...initStat }, A2: { ...initStat }, B1: { ...initStat }, B2: { ...initStat } };
                let statsPair = { A: { totalPoints: 0, serves: 0, serves1st: 0, firstIn: 0, faults: 0, doubleFaults: 0, aces: 0 }, B: { totalPoints: 0, serves: 0, serves1st: 0, firstIn: 0, faults: 0, doubleFaults: 0, aces: 0 } };
                let gameStats = [];
                let tempGameStats = { gameIndex: 1, serverPlayer: null, stats: { serves: 0, serves1st: 0, firstIn: 0, faults: 0, doubleFaults: 0 } };

                const pushGameStats = (serverPlayerID) => {
                    const s = tempGameStats.stats;
                    const rate1st = s.serves1st === 0 ? 0 : Math.round((s.firstIn / s.serves1st) * 100);
                    const totalIn = s.serves - s.faults - s.doubleFaults;
                    const rateTotal = s.serves === 0 ? 0 : Math.round((totalIn / s.serves) * 100);
                    gameStats.push({ gameIndex: tempGameStats.gameIndex, serverPlayer: serverPlayerID, stats: { rate1st, rateTotal } });
                    tempGameStats.gameIndex++; 
                    tempGameStats.stats = { serves: 0, serves1st: 0, firstIn: 0, faults: 0, doubleFaults: 0 };
                };

                const calculatedTimeline = [];
                let isSecondServe = false;

                history.forEach((rawEvent) => {
                    const eventServerPlayer = rawEvent.serverPlayer;
                    const eventServerSide = eventServerPlayer ? eventServerPlayer.charAt(0) : state.currentServerSide;

                    if (eventServerPlayer && stats[eventServerPlayer]) {
                        const s = stats[eventServerPlayer];
                        const ts = tempGameStats.stats;
                        const ps = statsPair[eventServerSide];

                        tempGameStats.serverPlayer = eventServerPlayer;

                        if (!isSecondServe) { 
                            s.serves1st++; ts.serves1st++; ps.serves1st++;
                        }

                        if (rawEvent.type === 'FAULT') {
                            s.serves++; s.faults++; ts.serves++; ts.faults++; ps.serves++; ps.faults++;
                        } else if (rawEvent.type === 'DOUBLE_FAULT') {
                            s.serves++; s.doubleFaults++; ts.serves++; ts.doubleFaults++; ps.serves++; ps.doubleFaults++;
                        } else {
                            s.serves++; ts.serves++; ps.serves++;
                            if (!isSecondServe) { s.firstIn++; ts.firstIn++; ps.firstIn++; }
                            if (rawEvent.type === 'ACE') { s.aces++; ps.aces++; }
                        }
                    }

                    const timelineItem = { ...rawEvent, calculatedServerSide: eventServerSide, isSecondServe: isSecondServe, scoreSnapshot: { ...state } };
                    
                    if (state.winner) { calculatedTimeline.push(timelineItem); return; }
                    
                    if (rawEvent.type === 'FAULT') { 
                        isSecondServe = true; 
                        calculatedTimeline.push(timelineItem); 
                        return; 
                    }
                    isSecondServe = false;
                    
                    let winnerSide = rawEvent.winner;
                    if (rawEvent.type === 'DOUBLE_FAULT') winnerSide = eventServerSide === 'A' ? 'B' : 'A'; 
                    if (winnerSide) {
                        statsPair[winnerSide].totalPoints++;
                    }

                    if (!state.winner) {
                        if (state.isTiebreak) {
                            if (winnerSide === 'A') state.pointsA++; else state.pointsB++;
                            if ((state.pointsA >= 7 || state.pointsB >= 7) && Math.abs(state.pointsA - state.pointsB) >= 2) {
                                const winSetSide = state.pointsA > state.pointsB ? 'A' : 'B';
                                state.lastGameResult = { serverSide: state.gameServerSide, winnerSide: winSetSide };
                                if (winSetSide === 'A') state.gamesA++; else state.gamesB++;
                                if (state.gamesA > state.gamesB) state.setsA++; else state.setsB++;
                                pushGameStats(eventServerPlayer); 
                                
                                state.pointsA = 0; state.pointsB = 0; state.isTiebreak = false; state.gamesA = 0; state.gamesB = 0; 
                                if (state.setsA >= matchInfo.setsToWin) state.winner = 'A'; else if (state.setsB >= matchInfo.setsToWin) state.winner = 'B'; else state.gameServerSide = (state.gameServerSide === 'A' ? 'B' : 'A');
                            }
                        } else {
                            if (winnerSide === 'A') state.pointsA++; else state.pointsB++;
                            const hasAd = state.pointsA >= 3 && state.pointsB >= 3; 
                            let gameFinished = false;

                            if (hasAd) { 
                                if (matchInfo.noAd && state.pointsA === 4 && state.pointsB === 4) {} 
                                if (state.pointsA > state.pointsB + 1) { state.gamesA++; gameFinished = true; } 
                                else if (state.pointsB > state.pointsA + 1) { state.gamesB++; gameFinished = true; } 
                            } else { 
                                if (state.pointsA > 3) { state.gamesA++; gameFinished = true; } 
                                else if (state.pointsB > 3) { state.gamesB++; gameFinished = true; } 
                            }

                            if (gameFinished) {
                                const winGameSide = state.pointsA > state.pointsB ? 'A' : 'B';
                                state.lastGameResult = { serverSide: state.gameServerSide, winnerSide: winGameSide };
                                pushGameStats(eventServerPlayer); 
                                
                                state.pointsA = 0; state.pointsB = 0; state.gameServerSide = (state.gameServerSide === 'A' ? 'B' : 'A'); 
                                let setFinished = false;
                                const target = matchInfo.gamesToWinSet;
                                
                                if (state.gamesA === matchInfo.tiebreakAt && state.gamesB === matchInfo.tiebreakAt) { 
                                    state.isTiebreak = true; 
                                } else { 
                                    if ((state.gamesA >= target && state.gamesA >= state.gamesB + 2) || (state.gamesA === target + 1 && state.gamesB === target - 1)) setFinished = true; 
                                    else if ((state.gamesB >= target && state.gamesB >= state.gamesA + 2) || (state.gamesB === target + 1 && state.gamesA === target - 1)) setFinished = true; 
                                }
                                
                                if (setFinished) { 
                                    if (state.gamesA > state.gamesB) state.setsA++; else state.setsB++; 
                                    if (state.setsA >= matchInfo.setsToWin) state.winner = 'A'; else if (state.setsB >= matchInfo.setsToWin) state.winner = 'B'; 
                                    else { state.gamesA = 0; state.gamesB = 0; }
                                }
                            }
                        }
                    }
                    
                    if (!state.winner) { 
                        if (state.isTiebreak) { 
                            const totalPts = state.pointsA + state.pointsB; const seq = totalPts % 4; 
                            if (seq === 0 || seq === 3) state.currentServerSide = state.gameServerSide; 
                            else state.currentServerSide = (state.gameServerSide === 'A' ? 'B' : 'A'); 
                        } else { 
                            state.currentServerSide = state.gameServerSide; 
                        } 
                    } else { 
                        state.currentServerSide = null; 
                    }
                    
                    calculatedTimeline.push(timelineItem);
                });

                return { currentScore: state, matchStats: { stats, statsPair, gameStats }, timeline: calculatedTimeline };
            }, [history, matchInfo]);

            useEffect(() => {
                if (!currentScore.currentServerSide) return;
                const side = currentScore.currentServerSide;
                const currentPlayerSide = currentServerPlayer.charAt(0);
                if (side !== currentPlayerSide) {
                    if (matchInfo.isDoubles) {
                        let lastServerForSide = null;
                        for (let i = timeline.length - 1; i >= 0; i--) { if (timeline[i].calculatedServerSide === side) { lastServerForSide = timeline[i].serverPlayer; break; } }
                        if (lastServerForSide) { const nextNum = lastServerForSide.endsWith('1') ? '2' : '1'; setCurrentServerPlayer(side + nextNum); } else { setCurrentServerPlayer(side + '1'); }
                    } else { setCurrentServerPlayer(side + '1'); }
                }
            }, [currentScore.currentServerSide, currentServerPlayer, matchInfo.isDoubles, timeline]);

            const isDeuce = !currentScore.isTiebreak && !matchInfo.noAd && currentScore.pointsA >= 3 && currentScore.pointsB >= 3 && currentScore.pointsA === currentScore.pointsB;
            const currentSide = currentScore.isTiebreak ? ((currentScore.pointsA + currentScore.pointsB) % 2 === 0 ? 'Deuce (å³)' : 'Ad (å·¦)') : ((currentScore.pointsA + currentScore.pointsB) % 2 === 0 ? 'Deuce (å³)' : 'Ad (å·¦)'); 
            const nextIsSecondServe = timeline.length > 0 && timeline[timeline.length - 1].type === 'FAULT';
            const displayPointA = currentScore.isTiebreak ? currentScore.pointsA : (isDeuce ? "Deuce" : (currentScore.pointsA > 3 && currentScore.pointsB > 3 ? (currentScore.pointsA > currentScore.pointsB ? "Ad" : "-") : (POINTS[Math.min(currentScore.pointsA, 5)] || currentScore.pointsA)));
            const displayPointB = currentScore.isTiebreak ? currentScore.pointsB : (isDeuce ? "Deuce" : (currentScore.pointsB > 3 && currentScore.pointsA > 3 ? (currentScore.pointsB > currentScore.pointsA ? "Ad" : "-") : (POINTS[Math.min(currentScore.pointsB, 5)] || currentScore.pointsB)));
            const currentServerStats = (() => { if (!matchStats.stats[currentServerPlayer]) return { r1: 0, rT: 0 }; const s = matchStats.stats[currentServerPlayer]; const r1 = s.serves1st === 0 ? 0 : Math.round((s.firstIn / s.serves1st) * 100); const tIn = s.serves - s.faults - s.doubleFaults; const rT = s.serves === 0 ? 0 : Math.round((tIn / s.serves) * 100); return { r1, rT }; })();

            // ==========================================
            // CSVä½œæˆãƒ­ã‚¸ãƒƒã‚¯
            // ==========================================
            const generateCSV = () => {
                let csvContent = "\uFEFF"; 
                
                csvContent += `Match Name,${matchInfo.matchName},,,,Date,${new Date().toLocaleDateString()}\n`;
                csvContent += `Format,${matchInfo.isDoubles ? 'Doubles' : 'Singles'},${matchInfo.matchType},,,Final Score,${currentScore.setsA}-${currentScore.setsB} (${currentScore.gamesA}-${currentScore.gamesB})\n`;
                const teamA = matchInfo.isDoubles ? `${matchInfo.playerA1} & ${matchInfo.playerA2}` : matchInfo.playerA1;
                const teamB = matchInfo.isDoubles ? `${matchInfo.playerB1} & ${matchInfo.playerB2}` : matchInfo.playerB1;
                const winnerName = currentScore.winner === 'A' ? teamA : (currentScore.winner === 'B' ? teamB : '-');
                csvContent += `Team A,${teamA},,,Winner,${winnerName}\n`;
                csvContent += `Team B,${teamB}\n\n`;

                csvContent += "Player Stats,Serves,1st In,1st %,2nd In,2nd %,DF,Aces,Points Won\n";
                const players = ['A1', 'A2', 'B1', 'B2'];
                players.forEach(pKey => {
                    const pName = pKey === 'A1' ? matchInfo.playerA1 : pKey === 'A2' ? matchInfo.playerA2 : pKey === 'B1' ? matchInfo.playerB1 : matchInfo.playerB2;
                    if (!pName || (!matchInfo.isDoubles && (pKey === 'A2' || pKey === 'B2'))) return;
                    const s = matchStats.stats[pKey];
                    const rate1st = s.serves1st === 0 ? "0%" : Math.round((s.firstIn / s.serves1st) * 100) + "%";
                    const totalIn = s.serves - s.faults - s.doubleFaults;
                    const rateTotal = s.serves === 0 ? "0%" : Math.round((totalIn / s.serves) * 100) + "%";
                    const secondIn = totalIn - s.firstIn;
                    const secondAttempts = s.faults; 
                    const secondRate = secondAttempts > 0 ? Math.round((secondIn / secondAttempts) * 100) + "%" : "-";
                    csvContent += `${pName},${s.serves},${s.firstIn},${rate1st},${secondIn},${secondRate},${s.doubleFaults},${s.aces},${s.totalPoints}\n`;
                });
                csvContent += "\n";

                csvContent += "No.,Game,ã‚µãƒ¼ãƒãƒ¼,ã‚µã‚¤ãƒ‰,Fault,å†…å®¹,ãƒã‚¤ãƒ³ãƒˆå‹è€…,ã‚µãƒ¼ãƒãƒ¼P,ãƒ¬ã‚·ãƒ¼ãƒãƒ¼P,ã‚²ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆ,å‚™è€ƒ,ã‚³ãƒ¡ãƒ³ãƒˆ\n";
                
                let seq = 1;

                timeline.forEach((t, index) => {
                    const s = t.scoreSnapshot; 
                    const gameNum = s.gamesA + s.gamesB + 1;
                    
                    let serverName = "";
                    if (t.serverPlayer === 'A1') serverName = matchInfo.playerA1;
                    else if (t.serverPlayer === 'A2') serverName = matchInfo.playerA2;
                    else if (t.serverPlayer === 'B1') serverName = matchInfo.playerB1;
                    else if (t.serverPlayer === 'B2') serverName = matchInfo.playerB2;

                    const totalPoints = s.pointsA + s.pointsB;
                    let sideStr = s.isTiebreak ? "TB" : (totalPoints % 2 === 0 ? "ãƒ•ã‚©ã‚¢" : "ãƒãƒƒã‚¯");
                    const faultStr = t.type === 'FAULT' ? "Fault" : (t.isSecondServe ? "2nd" : "1st");
                    
                    let contentStr = t.type;
                    if (t.type === 'ACE') contentStr = "ã‚¨ãƒ¼ã‚¹";
                    else if (t.type === 'DOUBLE_FAULT') contentStr = "ãƒ€ãƒ–ãƒ«ãƒ•ã‚©ãƒ«ãƒˆ";
                    else if (t.type === 'SERVER_P') contentStr = "ã‚µãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ";
                    else if (t.type === 'RECEIVER_P') contentStr = "ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ";
                    
                    let winnerRole = "";
                    if (t.type !== 'FAULT') {
                        if (t.winner === t.calculatedServerSide) winnerRole = "ã‚µãƒ¼ãƒãƒ¼";
                        else winnerRole = "ãƒ¬ã‚·ãƒ¼ãƒãƒ¼";
                    }

                    let nextPointsA = s.pointsA;
                    let nextPointsB = s.pointsB;
                    if (t.type !== 'FAULT') {
                        if (t.winner === 'A') nextPointsA++; else nextPointsB++;
                    }
                    
                    let serverP = "";
                    let receiverP = "";
                    let ptS = t.calculatedServerSide === 'A' ? nextPointsA : nextPointsB; 
                    let ptR = t.calculatedServerSide === 'A' ? nextPointsB : nextPointsA; 
                    
                    let isGameEnd = false;       
                    let gameWinnerSide = null;   

                    if (t.type === 'FAULT') {
                        serverP = ""; receiverP = "";
                    } else if (s.isTiebreak) {
                        serverP = ptS;
                        receiverP = ptR;
                        if ((ptS >= 7 || ptR >= 7) && Math.abs(ptS - ptR) >= 2) {
                            isGameEnd = true;
                            if (ptS > ptR) gameWinnerSide = t.calculatedServerSide; 
                            else gameWinnerSide = t.calculatedServerSide === 'A' ? 'B' : 'A';
                        }
                    } else {
                        if (ptS >= 4 || ptR >= 4) {
                            if (matchInfo.noAd) {
                                 if (ptS >= 4) { serverP = "GAME"; receiverP = "-"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide; }
                                 else { serverP = "-"; receiverP = "GAME"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide === 'A' ? 'B' : 'A'; }
                            } else {
                                 if (ptS >= 3 && ptR >= 3) {
                                     if (ptS === ptR) { serverP = "Deuce"; receiverP = "Deuce"; }
                                     else if (ptS === ptR + 1) { serverP = "Ad"; receiverP = "-"; }
                                     else if (ptR === ptS + 1) { serverP = "-"; receiverP = "Ad"; }
                                     else if (ptS >= ptR + 2) { serverP = "GAME"; receiverP = "-"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide; }
                                     else if (ptR >= ptS + 2) { serverP = "-"; receiverP = "GAME"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide === 'A' ? 'B' : 'A'; }
                                 } else {
                                     if (ptS >= 4) { serverP = "GAME"; receiverP = "-"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide; }
                                     else { serverP = "-"; receiverP = "GAME"; isGameEnd = true; gameWinnerSide = t.calculatedServerSide === 'A' ? 'B' : 'A'; }
                                 }
                            }
                        } else {
                            if (!matchInfo.noAd && ptS === 3 && ptR === 3) {
                                serverP = "Deuce"; receiverP = "Deuce";
                            } else {
                                serverP = POINTS[ptS]; receiverP = POINTS[ptR];
                            }
                        }
                    }

                    const gameCountStr = `${s.gamesA}-${s.gamesB}`;
                    let note = "";
                    
                    if (isGameEnd) {
                        if (gameWinnerSide === s.gameServerSide) {
                            note = "Keep";
                        } else {
                            note = "Break";
                        }
                        
                        if (index === timeline.length - 1 && currentScore.winner) {
                            contentStr += " (MATCH)";
                        } else {
                            contentStr += " (GAME)";
                        }
                    }

                    const commentStr = t.comment ? `"${t.comment.replace(/"/g, '""')}"` : "";

                    csvContent += `${seq},${gameNum},${serverName},${sideStr},${faultStr},${contentStr},${winnerRole},${serverP},${receiverP},${gameCountStr},${note},${commentStr}\n`;
                    seq++;
                });
                return csvContent;
            };

            const exportCSV = () => { const csvContent = "data:text/csv;charset=utf-8," + encodeURIComponent(generateCSV()); const link = document.createElement("a"); link.setAttribute("href", csvContent); link.setAttribute("download", `tennis_match_${new Date().toISOString().slice(0,10)}.csv`); document.body.appendChild(link); link.click(); document.body.removeChild(link); };
            
            const sendToGas = (type, payload) => { 
                let body = { type, ...payload }; 
                if (type === 'match_finish') body.csvData = generateCSV(); 
                fetch(DEFAULT_GAS_URL, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify(body) })
                .then(() => { alert('é€ä¿¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã‚Šã¾ã—ãŸ'); })
                .catch(err => { alert('é€ä¿¡ã‚¨ãƒ©ãƒ¼: ' + err.message); }); 
            };

            if (screen === 'setup') {
                return (
                    <div className="min-h-screen p-4 flex items-center justify-center max-w-md mx-auto bg-[#f0fdf4] select-none relative">
                        {/* è¨˜éŒ²å†é–‹ç¢ºèªç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« */}
                        <ConfirmModal 
                            isOpen={showResumeModal} 
                            onClose={handleResumeNo} 
                            onConfirm={handleResumeYes} 
                            title="è¨˜éŒ²ã®å†é–‹" 
                            message="å‰å›ã®è©¦åˆè¨˜éŒ²ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚&#10;è¨˜éŒ²ã‚’å†é–‹ã—ã¾ã™ã‹ï¼Ÿ" 
                            confirmText="ã¯ã„ï¼ˆå†é–‹ã™ã‚‹ï¼‰" 
                            cancelText="ã„ã„ãˆï¼ˆæ–°ã—ãå§‹ã‚ã‚‹ï¼‰" 
                            confirmColor="primary" 
                        />

                        <Card className="w-full p-6">
                            <div className="flex items-center gap-2 mb-6 text-blue-800"><Trophy className="w-6 h-6" /><h1 className="text-2xl font-bold">è©¦åˆè¨­å®š</h1></div>
                            <div className="space-y-4">
                                <div><label className="block text-sm font-medium text-gray-700 mb-1">è©¦åˆå</label><input type="text" className="w-full p-2 border rounded-md" value={matchInfo.matchName} onChange={(e) => setMatchInfo({...matchInfo, matchName: e.target.value})}/></div>
                                <div className="flex items-center gap-2 pb-2 border-b border-gray-100"><input type="checkbox" id="isDoubles" checked={matchInfo.isDoubles} onChange={e => setMatchInfo({...matchInfo, isDoubles: e.target.checked})} className="w-4 h-4 text-blue-600 rounded" /><label htmlFor="isDoubles" className="text-sm font-bold text-gray-700">ãƒ€ãƒ–ãƒ«ã‚¹</label></div>
                                <div className="space-y-3">
                                    <div className="bg-blue-50 p-3 rounded"><div className="text-xs text-blue-700 font-bold mb-2">ãƒšã‚¢ A</div><PlayerSelectInput label="é¸æ‰‹ A1" value={matchInfo.playerA1} onChange={(val) => setMatchInfo(prev => ({ ...prev, playerA1: val }))} playerList={playerList}/>{matchInfo.isDoubles && (<div className="mt-2"><PlayerSelectInput label="é¸æ‰‹ A2" value={matchInfo.playerA2} onChange={(val) => setMatchInfo(prev => ({ ...prev, playerA2: val }))} playerList={playerList}/></div>)}</div>
                                    <div className="bg-red-50 p-3 rounded"><div className="text-xs text-red-700 font-bold mb-2">ãƒšã‚¢ B</div><PlayerSelectInput label="é¸æ‰‹ B1" value={matchInfo.playerB1} onChange={(val) => setMatchInfo(prev => ({ ...prev, playerB1: val }))} playerList={playerList}/>{matchInfo.isDoubles && (<div className="mt-2"><PlayerSelectInput label="é¸æ‰‹ B2" value={matchInfo.playerB2} onChange={(val) => setMatchInfo(prev => ({ ...prev, playerB2: val }))} playerList={playerList}/></div>)}</div>
                                </div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div><label className="block text-sm font-medium text-gray-700 mb-1">ãƒãƒƒãƒå½¢å¼</label><select className="w-full p-2 border rounded-md bg-white" value={matchInfo.matchType} onChange={(e) => { let newConfig = { matchType: e.target.value }; switch(e.target.value) { case '1set': newConfig = { ...newConfig, setsToWin: 1, gamesToWinSet: 6, tiebreakAt: 6 }; break; case '8game': newConfig = { ...newConfig, setsToWin: 1, gamesToWinSet: 8, tiebreakAt: 7 }; break; case '3set': newConfig = { ...newConfig, setsToWin: 2, gamesToWinSet: 6, tiebreakAt: 6 }; break; case '4game': newConfig = { ...newConfig, setsToWin: 1, gamesToWinSet: 4, tiebreakAt: 4 }; break; } setMatchInfo(prev => ({ ...prev, ...newConfig })); }}><option value="1set">1ã‚»ãƒƒãƒˆãƒãƒƒãƒ</option><option value="8game">8ã‚²ãƒ¼ãƒ ãƒãƒƒãƒ</option><option value="3set">3ã‚»ãƒƒãƒˆãƒãƒƒãƒ</option><option value="4game">4ã‚²ãƒ¼ãƒ å…ˆå–</option></select></div>
                                    <div><label className="block text-sm font-medium text-gray-700 mb-1">æœ€åˆã®ã‚µãƒ¼ãƒãƒ¼</label><div className="flex bg-gray-100 rounded-md p-1">{['A', 'B'].map(p => (<button key={p} onClick={() => setMatchInfo({...matchInfo, serverFirst: p})} className={`flex-1 py-1 text-sm rounded ${matchInfo.serverFirst === p ? 'bg-white shadow text-blue-600 font-bold' : 'text-gray-500'}`}>{p === 'A' ? 'A' : 'B'}</button>))}</div></div>
                                </div>
                                <div className="flex items-center gap-2 pt-2"><input type="checkbox" id="noad" checked={matchInfo.noAd} onChange={e => setMatchInfo({...matchInfo, noAd: e.target.checked})} className="w-4 h-4 text-blue-600 rounded" /><label htmlFor="noad" className="text-gray-700">ãƒãƒ¼ã‚¢ãƒ‰ãƒãƒ³ãƒ†ãƒ¼ã‚¸</label></div>
                                <Button className="w-full mt-6" size="lg" onClick={() => setScreen('match')}>è©¦åˆé–‹å§‹</Button>
                            </div>
                        </Card>
                    </div>
                );
            }

            return (
                <div className="max-w-md mx-auto min-h-screen flex flex-col bg-slate-50 relative select-none">
                    <div className="bg-slate-900 text-white p-4 pb-6 rounded-b-3xl shadow-lg sticky top-0 z-50 shrink-0">
                        <div className="flex justify-between items-center mb-4 opacity-70 text-sm"><span>{matchInfo.matchName}</span><div className="flex gap-2 items-center"><button onClick={() => setScreen(screen === 'match' ? 'stats' : 'match')} className="p-1 hover:text-blue-300 cursor-pointer">{screen === 'match' ? <Activity size={20}/> : <Zap size={20}/>}</button>{screen === 'match' && (<><button onClick={() => setShowGasModal(true)} className="p-1 hover:text-blue-300 cursor-pointer"><CloudUpload size={20} /></button><button onClick={() => setShowHistory(!showHistory)} className={`p-1 hover:text-blue-300 ${showHistory ? 'text-blue-400' : ''} cursor-pointer`}><Menu size={20} /></button></>)}<button onClick={exportCSV} className="p-1 hover:text-green-300 cursor-pointer"><Save size={20}/></button></div></div>
                        <div className="flex justify-between items-center text-center">
                            <div className={`flex-1 transition-all ${currentScore.currentServerSide === 'A' ? 'scale-105' : 'opacity-80'}`}>
                                <div className="text-xs mb-1 text-slate-400">Pair A</div><div className="font-bold text-lg leading-tight"><div>{matchInfo.playerA1}</div>{matchInfo.isDoubles && <div className="text-sm">{matchInfo.playerA2}</div>}</div>
                                {currentScore.currentServerSide === 'A' && (<div className="mt-2 flex flex-col items-center animate-in fade-in"><div className="text-yellow-400 text-xs flex justify-center items-center gap-1 font-bold"><div className="w-2 h-2 rounded-full bg-yellow-400"></div>Server</div>{matchInfo.isDoubles && (<div className="flex gap-1 mt-1"><button onClick={() => setCurrentServerPlayer('A1')} className={`text-[10px] px-2 py-0.5 rounded border ${currentServerPlayer === 'A1' ? 'bg-yellow-400 text-black border-yellow-400' : 'text-slate-400 border-slate-600'}`}>{matchInfo.playerA1.slice(0,4)}..</button><button onClick={() => setCurrentServerPlayer('A2')} className={`text-[10px] px-2 py-0.5 rounded border ${currentServerPlayer === 'A2' ? 'bg-yellow-400 text-black border-yellow-400' : 'text-slate-400 border-slate-600'}`}>{matchInfo.playerA2.slice(0,4)}..</button></div>)}<div className="text-xs text-slate-300 mt-1 font-bold leading-tight flex flex-col gap-0.5"><span>1st: {currentServerStats.r1}%</span><span>Total: {currentServerStats.rT}%</span></div></div>)}
                            </div>
                            <div className="flex flex-col items-center mx-2 bg-slate-800 px-3 py-2 rounded-lg"><div className="text-xs text-slate-400 mb-1">SETS</div><div className="flex gap-4 text-xl font-mono font-bold"><span>{currentScore.setsA}</span><span className="text-slate-500">-</span><span>{currentScore.setsB}</span></div><div className="text-xs text-slate-400 mt-2 mb-1">GAMES</div><div className="flex gap-4 text-lg font-mono text-blue-300"><span>{currentScore.gamesA}</span><span className="text-slate-600">-</span><span>{currentScore.gamesB}</span></div></div>
                            <div className={`flex-1 transition-all ${currentScore.currentServerSide === 'B' ? 'scale-105' : 'opacity-80'}`}>
                                <div className="text-xs mb-1 text-slate-400">Pair B</div><div className="font-bold text-lg leading-tight"><div>{matchInfo.playerB1}</div>{matchInfo.isDoubles && <div className="text-sm">{matchInfo.playerB2}</div>}</div>
                                {currentScore.currentServerSide === 'B' && (<div className="mt-2 flex flex-col items-center animate-in fade-in"><div className="text-yellow-400 text-xs flex justify-center items-center gap-1 font-bold"><div className="w-2 h-2 rounded-full bg-yellow-400"></div>Server</div>{matchInfo.isDoubles && (<div className="flex gap-1 mt-1"><button onClick={() => setCurrentServerPlayer('B1')} className={`text-[10px] px-2 py-0.5 rounded border ${currentServerPlayer === 'B1' ? 'bg-yellow-400 text-black border-yellow-400' : 'text-slate-400 border-slate-600'}`}>{matchInfo.playerB1.slice(0,4)}..</button><button onClick={() => setCurrentServerPlayer('B2')} className={`text-[10px] px-2 py-0.5 rounded border ${currentServerPlayer === 'B2' ? 'bg-yellow-400 text-black border-yellow-400' : 'text-slate-400 border-slate-600'}`}>{matchInfo.playerB2.slice(0,4)}..</button></div>)}<div className="text-xs text-slate-300 mt-1 font-bold leading-tight flex flex-col gap-0.5"><span>1st: {currentServerStats.r1}%</span><span>Total: {currentServerStats.rT}%</span></div></div>)}
                            </div>
                        </div>
                        <div className="mt-6 flex justify-center items-center gap-4"><div className={`${isDeuce ? "text-3xl" : "text-5xl"} font-mono font-bold ${displayPointA === 'Ad' || displayPointA === 'Deuce' ? 'text-yellow-400' : ''}`}>{displayPointA}</div><div className="text-slate-600 text-2xl">:</div><div className={`${isDeuce ? "text-3xl" : "text-5xl"} font-mono font-bold ${displayPointB === 'Ad' || displayPointB === 'Deuce' ? 'text-yellow-400' : ''}`}>{displayPointB}</div></div>
                        <div className="mt-4 flex justify-between text-xs font-mono bg-slate-800 rounded px-3 py-1 text-slate-300"><span>SIDE: {currentSide}</span><span>SERVE: {nextIsSecondServe ? '2nd' : '1st'}</span></div>
                    </div>

                    {screen === 'stats' && (
                        <div className="p-4 space-y-4 animate-in fade-in zoom-in duration-300 pb-12 overflow-y-auto">
                            <Card className="p-4 mb-4"><StatsGraphs gameStats={matchStats.gameStats} matchInfo={matchInfo} /></Card>
                            <Card className="p-4">
                                <div className="text-sm font-bold text-gray-700 mb-2 border-b pb-1">ãƒšã‚¢åˆè¨ˆã‚¹ã‚¿ãƒƒãƒ„</div>
                                <div className="grid grid-cols-3 gap-2 text-center text-sm mb-6"><div className="font-bold text-blue-600">Pair A</div><div className="text-gray-400">é …ç›®</div><div className="font-bold text-red-600">Pair B</div><div>{matchStats.statsPair.A.totalPoints}</div><div className="text-xs text-gray-500 py-1">ç·ãƒã‚¤ãƒ³ãƒˆ</div><div>{matchStats.statsPair.B.totalPoints}</div>
                                <div>{matchStats.statsPair.A.aces}</div><div className="text-xs text-gray-500 py-1">ã‚¨ãƒ¼ã‚¹/ã‚¦ã‚£ãƒŠãƒ¼</div><div>{matchStats.statsPair.B.aces}</div>
                                <div>{matchStats.statsPair.A.doubleFaults}</div><div className="text-xs text-gray-500 py-1">ãƒ€ãƒ–ãƒ«ãƒ•ã‚©ãƒ«ãƒˆ</div><div>{matchStats.statsPair.B.doubleFaults}</div>
                                <div>{matchStats.statsPair.A.serves > 0 ? Math.round((matchStats.statsPair.A.firstIn / matchStats.statsPair.A.serves) * 100) : 0}%</div><div className="text-xs text-gray-500 py-1">1stã‚µãƒ¼ãƒ–æˆåŠŸç‡</div><div>{matchStats.statsPair.B.serves > 0 ? Math.round((matchStats.statsPair.B.firstIn / matchStats.statsPair.B.serves) * 100) : 0}%</div>
                                </div>

                                <div className="text-sm font-bold text-gray-700 mb-2 border-b pb-1">å€‹äººåˆ¥ã‚µãƒ¼ãƒ–ã‚¹ã‚¿ãƒƒãƒ„</div>
                                {[{ p: 'A1', name: matchInfo.playerA1, bg: 'bg-blue-50' }, ...(matchInfo.isDoubles ? [{ p: 'A2', name: matchInfo.playerA2, bg: 'bg-blue-50' }] : []), { p: 'B1', name: matchInfo.playerB1, bg: 'bg-red-50' }, ...(matchInfo.isDoubles ? [{ p: 'B2', name: matchInfo.playerB2, bg: 'bg-red-50' }] : [])].map(player => {
                                    const s = matchStats.stats[player.p];
                                    const r1 = s.serves1st === 0 ? 0 : Math.round((s.firstIn / s.serves1st) * 100);
                                    const tIn = s.serves - s.faults - s.doubleFaults;
                                    const rT = s.serves === 0 ? 0 : Math.round((tIn / s.serves) * 100);
                                    return (
                                        <div key={player.p} className={`${player.bg} p-2 rounded mb-2 text-sm`}><div className="font-bold mb-1">{player.name}</div><div className="flex justify-between text-xs text-gray-600"><span>1stæˆåŠŸ: {r1}% ({s.firstIn}/{s.serves1st})</span><span>å…¨æˆåŠŸ: {rT}%</span><span>DF: {s.doubleFaults}</span><span>Ace: {s.aces}</span></div></div>
                                    );
                                })}
                            </Card>
                            <Button variant="secondary" className="w-full mt-4" onClick={() => setScreen('match')}>ã‚¹ã‚³ã‚¢å…¥åŠ›ã«æˆ»ã‚‹</Button>
                        </div>
                    )}

                    {screen === 'match' && !currentScore.winner && (
                        <div className="flex-1 flex flex-col h-full overflow-hidden relative">
                            {showHistory ? (
                                <div className="flex-1 overflow-y-auto p-4 space-y-2 bg-slate-50 border-t border-slate-200 animate-in slide-in-from-top-4">
                                    <div className="text-xs font-bold text-slate-400 mb-2 px-1 flex justify-between items-center"><span>ãƒã‚¤ãƒ³ãƒˆå±¥æ­´</span><button onClick={() => setShowHistory(false)}><X size={16}/></button></div>
                                    {[...timeline].reverse().map((event, reverseIndex) => {
                                        const realIndex = timeline.length - 1 - reverseIndex;
                                        const isWinA = event.winner === 'A';
                                        return (
                                            <div key={event.id} className="bg-white p-2 rounded shadow-sm border border-slate-100 flex justify-between items-center">
                                                <div className="flex items-center gap-3">
                                                    <div className="flex flex-col items-center w-8">
                                                        <span className="text-[10px] text-slate-400">{event.calculatedServerSide}: {event.serverPlayer}</span>
                                                        <span className="font-mono font-bold text-sm text-slate-600">{event.scoreSnapshot.gamesA}-{event.scoreSnapshot.gamesB}</span>
                                                    </div>
                                                    <div className="flex flex-col">
                                                        <div className="flex items-baseline gap-2">
                                                            <span className={`font-bold ${isWinA ? 'text-blue-600' : 'text-red-600'}`}>{isWinA ? 'Pair A' : 'Pair B'}</span>
                                                            <span className="text-xs text-slate-500 bg-slate-100 px-1 rounded">{event.type}</span>
                                                        </div>
                                                        {event.comment && (
                                                            <div className="text-[10px] text-slate-500 mt-1 flex items-center gap-1 opacity-80">
                                                                <MessageSquare size={10} /> {event.comment}
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                                <button onClick={() => setEditingEventIndex(realIndex)} className="p-2 text-slate-400 hover:text-blue-600"><Pencil size={16} /></button>
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (<div className="flex-1 bg-slate-50 flex items-center justify-center opacity-10"><div className="text-6xl text-slate-300 pointer-events-none select-none">ğŸ¾</div></div>)}
                            <div className="p-3 bg-white border-t border-slate-200 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] z-20 shrink-0 pb-8">
                                <div className="grid grid-cols-2 gap-2 mb-2">
                                    <Button variant="warning" className="h-16 relative" onClick={() => handlePoint('FAULT', currentScore.currentServerSide === 'A' ? 'B' : 'A')} disabled={nextIsSecondServe}><span className="flex flex-col items-center"><span>FAULT</span><span className="text-[10px] opacity-75">ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆ</span></span></Button>
                                    {nextIsSecondServe && (<div className="absolute inset-0 bg-white/50 z-20 flex items-center justify-center pointer-events-none rounded-lg left-0 w-1/2 ml-0"><span className="text-red-600 font-bold bg-white px-2 py-1 rounded shadow text-xs">2nd Serve</span></div>)}
                                    <Button variant="danger" className="h-16" onClick={() => handlePoint('DOUBLE_FAULT', currentScore.currentServerSide === 'A' ? 'B' : 'A')} disabled={!nextIsSecondServe}><span className="flex flex-col items-center"><span>DBL FAULT</span><span className="text-[10px] opacity-75">ãƒ€ãƒ–ãƒ«ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆ</span></span></Button>
                                </div>
                                <div className="grid grid-cols-2 gap-3">
                                    <div className="space-y-2 flex flex-col">
                                        <Button variant="primary" className="h-16 w-full" onClick={() => handlePoint('SERVER_P', currentScore.currentServerSide)}><span className="flex flex-col items-center"><span>ã‚µãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ</span></span></Button>
                                        <Button variant="primary" className="h-10 w-full opacity-90" onClick={() => handlePoint('ACE', currentScore.currentServerSide)}><span className="flex flex-col items-center text-xs"><span>ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ¼ã‚¹</span></span></Button>
                                    </div>
                                    <div className="space-y-2 flex flex-col">
                                        <Button variant="secondary" className="h-full min-h-[110px] w-full border-red-200 text-red-700 bg-red-50" onClick={() => handlePoint('RECEIVER_P', currentScore.currentServerSide === 'A' ? 'B' : 'A')}><span className="flex flex-col items-center"><span>ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ãƒã‚¤ãƒ³ãƒˆ</span></span></Button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {currentScore.winner && (
                        <div className="flex-1 flex flex-col items-center justify-center p-8 animate-in zoom-in">
                            <Trophy size={64} className="text-yellow-500 mb-4" /><h2 className="text-3xl font-bold text-slate-800 mb-2">Match Finished!</h2><p className="text-xl text-slate-600 mb-8">Winner: {currentScore.winner === 'A' ? "Pair A" : "Pair B"}</p>
                            <div className="flex flex-col gap-4 w-full"><div className="flex gap-4"><Button className="flex-1" onClick={() => setScreen('stats')}>ã‚¹ã‚¿ãƒƒãƒ„ã‚’è¦‹ã‚‹</Button><Button variant="secondary" onClick={exportCSV}>CSVä¿å­˜(ãƒ­ãƒ¼ã‚«ãƒ«)</Button></div><Button className="w-full flex gap-2 items-center justify-center" variant="success" size="lg" onClick={() => setShowGasModal(true)}><CloudUpload size={20}/> çµæœã‚’Slack/Driveã¸ä¿å­˜</Button><Button className="w-full flex gap-2 items-center justify-center" variant="danger" size="lg" onClick={confirmReset}><RefreshCw size={20}/> æ–°ã—ã„è¨˜éŒ²ã‚’å§‹ã‚ã‚‹</Button></div>
                        </div>
                    )}

                    <EditModal isOpen={editingEventIndex !== null} onClose={() => setEditingEventIndex(null)} event={editingEventIndex !== null ? history[editingEventIndex] : null} onSave={handleUpdateHistory} onDelete={handleDeleteHistory} matchInfo={matchInfo} />
                    <GasModal isOpen={showGasModal} onClose={() => setShowGasModal(false)} matchInfo={matchInfo} currentScore={currentScore} onSend={sendToGas} onResetRequest={confirmReset} />
                    <ConfirmModal isOpen={showResetConfirm} onClose={() => setShowResetConfirm(false)} onConfirm={executeReset} title="æ–°ã—ã„è¨˜éŒ²ã‚’å§‹ã‚ã¾ã™ã‹ï¼Ÿ" message={"ç¾åœ¨ã®è©¦åˆè¨˜éŒ²ã¯ã‚¯ãƒªã‚¢ã•ã‚Œã€åˆæœŸç”»é¢ã«æˆ»ã‚Šã¾ã™ã€‚\nä¿å­˜ã—ã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã¯å®Œå…¨ã«æ¶ˆå»ã•ã‚Œã¾ã™ã€‚"} confirmText="çµ‚äº†ã—ã¦æ–°è¦ä½œæˆ" />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
ã€€ <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js');
    }
  </script>
</body>
</html>
